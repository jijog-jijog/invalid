
// ========================================
// UPDATE TASK FUNCTION
// ========================================
// Purpose: Execute task updates in Zenkit via PUT endpoint
// Endpoint: PUT /lists/{LIST_ID}/entries/{ENTRY_ID}
// Payload format: {UUID_fieldtype: value, ...}
// Input: Form values with task fields to update
// Output: Success/error message
response = Map();
formValues = form.get("values");
if(formValues == null)
{
	response.put("text","‚ùå ERROR: No form values received");
	return response;
}
info "formValues = " + formValues;
// Extract values from form
listIdValue = formValues.get("listId");
taskIdValue = formValues.get("taskId");
taskName = formValues.get("taskname");
dueDate = formValues.get("dueon");
assignTo = formValues.get("assignto");
category = formValues.get("category");
// Extract value from taskId if it's a Map (from form dropdown)
try 
{
	if(taskIdValue != null)
	{
		extractedValue = taskIdValue.get("value");
		if(extractedValue != null)
		{
			taskIdValue = extractedValue;
			info "Extracted taskId value from Map: " + taskIdValue;
		}
	}
}
catch (e)
{
	info "taskId is not a Map, using as-is: " + taskIdValue;
}
info "Extracted: listId=" + listIdValue + ", taskId=" + taskIdValue;
info "Updates: name=" + taskName + ", date=" + dueDate + ", assignTo=" + assignTo + ", category=" + category;
// Validate required fields
if(taskIdValue == null || taskIdValue == "")
{
	response.put("text","‚ùå ERROR: Task ID is required");
	return response;
}
if(listIdValue == null || listIdValue == "")
{
	response.put("text","‚ùå ERROR: List ID is required");
	return response;
}
// ========================================
// FETCH ENTRY TO EXTRACT DYNAMIC FIELD UUIDs
// ========================================
fieldUuidMap = Map();
try 
{
	entriesSearchUrl = "https://base.zenkit.com/api/v1/lists/" + listIdValue + "/entries/search";
	info "Fetching entries from: " + entriesSearchUrl;
	entriesResponse = invokeurl
	[
		url :entriesSearchUrl
		type :GET
		connection:"zenkitconnect"
	];
	info "Entries response received";
	info "Full response: " + entriesResponse;
	// Find our specific entry
	targetEntry = null;
	entriesCount = 0;
	if(entriesResponse != null)
	{
		info "Response is not null";
		try 
		{
			info "Attempting to iterate through entries...";
			for each  entry in entriesResponse
			{
				entriesCount = entriesCount + 1;
				entryId = entry.get("id");
				displayString = entry.get("displayString");
				info "Entry #" + entriesCount + ": id=" + entryId + ", displayString=" + displayString + ", taskIdValue=" + taskIdValue;
				info "Comparing: '" + entryId + "' == '" + taskIdValue + "'";
				// Try different comparison methods
				if(entryId + "" == taskIdValue + "")
				{
					targetEntry = entry;
					info "‚úÖ MATCH FOUND: Entry ID matches taskIdValue";
					break;
				}
				else if(entryId == taskIdValue)
				{
					targetEntry = entry;
					info "‚úÖ MATCH FOUND (direct comparison): Entry ID matches taskIdValue";
					break;
				}
				else
				{
					info "No match - continuing search";
				}
			}
			info "Total entries iterated: " + entriesCount;
		}
		catch (e)
		{
			info "‚ùå ERROR iterating entries: " + e;
		}
	}
	else
	{
		info "‚ùå Response is null!";
	}
	if(targetEntry == null)
	{
		info "‚ùå targetEntry is still null after iteration";
		info "Entries found: " + entriesCount;
		info "Looking for taskIdValue: " + taskIdValue;
		responseReceived = "No";
		if(entriesResponse != null)
		{
			responseReceived = "Yes";
		}
		response.put("text","‚ùå ERROR: Could not find task entry in list\n\nDebug Info:\n- Entries searched: " + entriesCount + "\n- Looking for taskId: " + taskIdValue + "\n- Response received: " + responseReceived);
		return response;
	}
	info "‚úÖ Target entry found successfully";
	// Extract field UUIDs from entry keys
	entryKeys = targetEntry.keys();
	info "Entry keys count: " + entryKeys.size();
	info "Entry keys: " + entryKeys.toString();
	for each  key in entryKeys
	{
		keyStr = key + "";
		// Look for fields by their suffix - match first _text field that isn't _searchText or _textType
		if(keyStr.contains("_text") && !keyStr.contains("_searchText") && !keyStr.contains("_textType") && !fieldUuidMap.containsKey("name_uuid"))
		{
			uuid = keyStr.replaceAll("_text","");
			fieldUuidMap.put("name_uuid",uuid);
			info "Found TEXT field UUID: " + uuid;
		}
		else if(keyStr.contains("_date") && !keyStr.contains("_endDate") && !keyStr.contains("_hasTime"))
		{
			uuid = keyStr.replaceAll("_date","");
			fieldUuidMap.put("date_uuid",uuid);
			info "Found DATE field UUID: " + uuid;
		}
		else if(keyStr.contains("_persons") && !keyStr.contains("_sort"))
		{
			uuid = keyStr.replaceAll("_persons","");
			fieldUuidMap.put("persons_uuid",uuid);
			info "Found PERSONS field UUID: " + uuid;
		}
		else if(keyStr.contains("_categories") && !keyStr.contains("_sort"))
		{
			uuid = keyStr.replaceAll("_categories","");
			fieldUuidMap.put("categories_uuid",uuid);
			info "Found CATEGORIES field UUID: " + uuid;
		}
	}
	info "Total field UUIDs found: " + fieldUuidMap.size();
	info "Field UUID Map: " + fieldUuidMap;
}
catch (e)
{
	info "‚ùå ERROR fetching entries: " + e;
	info "Error details: " + e;
	response.put("text","‚ùå ERROR: Failed to fetch entries\n\nError: " + e);
	return response;
}
// Check if we found the required field UUIDs
if(fieldUuidMap.size() == 0)
{
	response.put("text","‚ùå ERROR: Could not extract field UUIDs from entry data\n\nNo UUID fields were found in the entry");
	return response;
}
// ========================================
// BUILD UPDATE PAYLOAD WITH ALL FIELDS
// ========================================
updatePayload = Map();
// Add Name field (if provided)
if(taskName != null && taskName != "")
{
	nameUuid = fieldUuidMap.get("name_uuid");
	if(nameUuid != null)
	{
		updatePayload.put(nameUuid + "_text",taskName);
		info "Added name field: " + nameUuid + "_text = " + taskName;
	}
}
// Add Due Date field (if provided)
if(dueDate != null && dueDate != "")
{
	dateUuid = fieldUuidMap.get("date_uuid");
	if(dateUuid != null)
	{
		updatePayload.put(dateUuid + "_date",dueDate);
		updatePayload.put(dateUuid + "_hasTime",false);
		// Don't include _endDate if it's null - Zenkit API rejects null values
		info "Added date fields for: " + dateUuid;
	}
}
// Add Assign To field (if provided)
assignToLabel = assignTo;
if(assignTo != null && assignTo != "")
{
	personsUuid = fieldUuidMap.get("persons_uuid");
	if(personsUuid != null)
	{
		assignList = List();
		// Extract value if it's a Map
		assignValue = assignTo;
		try 
		{
			assignToLabel = assignTo.get("label");
			assignValue = assignTo.get("value");
		}
		catch (e)
		{
			assignValue = assignTo;
		}
		assignList.add(assignValue);
		updatePayload.put(personsUuid + "_persons",assignList);
		info "Added persons field: " + personsUuid + "_persons = " + assignList;
	}
}
// Add Category field (if provided)
categoryLabel = category;
if(category != null && category != "")
{
	categoriesUuid = fieldUuidMap.get("categories_uuid");
	if(categoriesUuid != null)
	{
		catList = List();
		// Extract value if it's a Map
		catValue = category;
		try 
		{
			categoryLabel = category.get("label");
			catValue = category.get("value");
		}
		catch (e)
		{
			catValue = category;
		}
		catList.add(catValue);
		updatePayload.put(categoriesUuid + "_categories",catList);
		info "Added categories field: " + categoriesUuid + "_categories = " + catList;
	}
}
// ========================================
// SEND UPDATE REQUEST TO ZENKIT
// ========================================
try 
{
	// Use the single entry endpoint (PUT /lists/{listId}/entries/{entryId})
	updateUrl = "https://base.zenkit.com/api/v1/lists/" + listIdValue + "/entries/" + taskIdValue;
	info "Sending update to: " + updateUrl;
	info "Update payload: " + updatePayload;
	updateResponse = invokeurl
	[
		url :updateUrl
		type :PUT
		parameters:updatePayload
		connection:"zenkitconnect"
	];
	info "Update response: " + updateResponse;
	info "Update completed successfully";
}
catch (e)
{
	info "Error updating task: " + e;
	response.put("text","‚ùå ERROR: Failed to update task - " + e);
	return response;
}
// ========================================
// RETURN SUCCESS MESSAGE WITH REDIRECT BUTTON
// ========================================
targetEntryShortId = targetEntry.get("shortId");
workspaceId = formValues.get("workspaceId");
// Use the NEW updated task name (not the old displayString from targetEntry)
entrySlug = taskName;
// Fetch workspace short ID from Zenkit API
workspaceShortId = "";
try 
{
	workspaceUrl = "https://base.zenkit.com/api/v1/workspaces/" + workspaceId;
	info "Fetching workspace info from: " + workspaceUrl;
	workspaceResponse = invokeurl
	[
		url :workspaceUrl
		type :GET
		connection:"zenkitconnect"
	];
	info "Workspace response: " + workspaceResponse;
	// Try different field names for short ID
	workspaceShortId = workspaceResponse.get("shortId");
	if(workspaceShortId == null || workspaceShortId == "")
	{
		workspaceShortId = workspaceResponse.get("short_id");
	}
	if(workspaceShortId == null || workspaceShortId == "")
	{
		workspaceShortId = workspaceResponse.get("id");
	}
	if(workspaceShortId == null || workspaceShortId == "")
	{
		workspaceShortId = workspaceResponse.get("uuid");
	}
	info "Workspace short ID found: " + workspaceShortId;
}
catch (e)
{
	info "‚ùå Could not fetch workspace short ID: " + e;
	info "Error details: " + e;
}
// Get list short ID (this is what's actually used in the Zenkit URL)
listShortId = "";
try 
{
	listUrl = "https://base.zenkit.com/api/v1/lists/" + listIdValue;
	listResponse = invokeurl
	[
		url :listUrl
		type :GET
		connection:"zenkitconnect"
	];
	info "List response: " + listResponse;
	listShortId = listResponse.get("shortId");
	if(listShortId == null || listShortId == "")
	{
		listShortId = listResponse.get("short_id");
	}
	info "List short ID found: " + listShortId;
	// Use list short ID in the URL (this is the correct one based on actual Zenkit URLs)
	if(listShortId != null && listShortId != "")
	{
		workspaceShortId = listShortId;
		info "Using list short ID for URL: " + workspaceShortId;
	}
}
catch (e)
{
	info "Could not fetch list short ID: " + e;
}
taskUrl = "";
if(workspaceShortId != null && targetEntryShortId != null && entrySlug != null)
{
	// Convert slug to proper format (lowercase, replace spaces with hyphens)
	entrySlug = entrySlug + "";
	entrySlug = entrySlug.toLowerCase();
	entrySlug = entrySlug.replaceAll(" ","-");
	// Format: https://base.zenkit.com/i/{workspace_short_id}/{entry_short_id}/{entry_slug}
	taskUrl = "https://base.zenkit.com/i/" + workspaceShortId + "/" + targetEntryShortId + "/" + entrySlug;
	info "Zenkit link: " + taskUrl;
}
response.put("type","message");
successText = "‚úÖ All fields updated successfully!\n\n";
if(taskName != null && taskName != "")
{
	successText = successText + "üìù Name: " + taskName + "\n";
}
if(dueDate != null && dueDate != "")
{
	successText = successText + "üìÖ Due Date: " + dueDate + "\n";
}
if(assignTo != null && assignTo != "")
{
	successText = successText + "üë§ Assigned To: " + assignToLabel + "\n";
}
if(category != null && category != "")
{
	successText = successText + "üè∑Ô∏è Category: " + categoryLabel + "\n";
}
response.put("text",successText);
// Add button to response
if(taskUrl != "" && taskUrl != null)
{
	try 
	{
		btn = Map();
		btn.put("label","üîó Open in Zenkit");
		btn.put("type","+");
		btn.put("action",{"type":"open.url","data":{"web":taskUrl}});
		btns = List();
		btns.add(btn);
		response.put("buttons",btns);
		info "Button added with URL: " + taskUrl;
	}
	catch (e)
	{
		info "Error creating button: " + e;
		// Fallback: add link to text
		successText = successText + "\n\nüîó [Open in Zenkit](" + taskUrl + ")";
		response.put("text",successText);
	}
}
return response;
